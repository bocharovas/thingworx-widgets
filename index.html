<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG geometry</title>
    <link rel="stylesheet" href="ui/circlegraph/circlegraph.runtime.css">
    <script src="ui/circlegraph/include/svg.min.js"></script>
    
    <!-- <script type="module" src="js/elem.geometry.js"></script> -->
</head>
<body>
    
</body>
    <script>
		function CreateCircle(canvasName, w, h , Radius_Mill, cCircle = SVG.Color.random(), cTitle = SVG.Color.random()) {

		// , cCircle = new SVG.Color('#fff')
		if(!Radius_Mill || Radius_Mill <= 0) return;

		const mCircle = canvasName.circle()
			.radius(Radius_Mill)
			.center(0,0)
			.fill('none')
			.addClass('mbCircle')
			.stroke({color: cCircle});

		function Point_st(L) { return  -L/2 + 10; }
		function Point_end(L){ return L/2 - 10;	  }

		const axis_x = [[Point_st(w), 0], [Point_end(w), 0]];
		const axis_y = [[0, Point_st(h)], [0, Point_end(h)]];

		// console.log("axis_xy: " + axis_x);

		const axisX_Line = canvasName.line(axis_x).addClass('axis_x');
		const axisY_Line = canvasName.line(axis_y).addClass('axis_y');

		let axisAdditional_group = canvasName.group();

		// function minDR_x(Arr){ return (Arr[1][0] - Arr[0][0])/2; }; // (1) > (2)

		// axisAdditional_group.line(axis_x).move(-minDR_x(axis_x), Radius_Mill).addClass('axis_x_0');
		// axisAdditional_group.line(axis_y).move(-Radius_Mill, -minDR_x(axis_x)).addClass('axis_y_0');
		// axisAdditional_group.line(axis_x).move(-minDR_x(axis_x), -Radius_Mill).addClass('axis_x_1');
		// axisAdditional_group.line(axis_y).move(Radius_Mill, -minDR_x(axis_x)).addClass('axis_y_1');


		// var axisAngleTitle_group = canvasName.group().addClass('axis_angle_title')
		// 											.fill({color: cTitle});
		// axisAngleTitle_group.text("0")      .move( Radius_Mill * 1.05, -Radius_Mill * 0.07).addClass('title_0');
		// axisAngleTitle_group.text("90")     .move( Radius_Mill * 0.05, -Radius_Mill * 1.07).addClass('title_90');
		// axisAngleTitle_group.text("180")    .move(-Radius_Mill * 1.09,  Radius_Mill * 0.05).addClass('title_180');
		// axisAngleTitle_group.text("270")    .move(-Radius_Mill * 0.09,  Radius_Mill * 1.05).addClass('title_270');
			
		}

        let width = window.innerWidth + 10;
        let height = window.innerHeight + 10;
        let cgColor = (new Array(10)).map(function(){return SVG.Color.random();});

        var thisWidget = {};
		let Rad_Mill = 3 * width/28 * 1/2 * 1/2;
		
        const canvasRT = SVG().addTo('body')
					.size(width, height)
					.viewbox(-width/16, -height/16, width/8, height/8);
			
			CreateCircle(canvasRT, width, height, Rad_Mill, cgColor[0], cgColor[1]);
			
			let vibroData1 = new Array();
			let alphaC = new Array();
			let alphaS = new Array();
			let points = 1100;
			//alert(Rad_Mill);
			for (let i=0; i < points; i++){
				vibroData1[i] = (Math.random() * 4 + (Rad_Mill - 10)).toFixed(3);
				//vibroData1[i] = 48;
				alphaC[i] = vibroData1[i] * Math.cos((360/points * i) * (Math.PI/180));
				alphaS[i] = vibroData1[i] * Math.sin((360/points * i) * (Math.PI/180));
			}
			//alert(Rad_Mill);
			let trajectoryPoint = new SVG.PathArray();
			trajectoryPoint[0] = ['M', alphaC[0], alphaS[0]];
			for (let i=1; i < points; i++){
				trajectoryPoint[i] = ['L', alphaC[i], alphaS[i]];
			}
			trajectoryPoint[points] = ['z'];
		    /*const trajectoryPoint = new SVG.PathArray([
				 ['M', 45 * Math.cos(0 * (Math.PI/180)), 45 * Math.sin(0 * (Math.PI/180))]                                             // Стартовая точка: 1
				,['L', 45 * Math.cos(90 * (Math.PI/180)), 45 * Math.sin(90 * (Math.PI/180))]          // Точка: 2
				,['L', 45 * Math.cos(180 * (Math.PI/180)), 45 * Math.sin(180 * (Math.PI/180))]
				,['L', 45 * Math.cos(270 * (Math.PI/180)), 45 * Math.sin(270 * (Math.PI/180))] 
				/*,['L', 45 * Math.cos(4 * 360/7), 45 * Math.sin(4 * 360/7)]          // Точка: 2
				,['L', 45 * Math.cos(5 * 360/7), 45 * Math.sin(5 * 360/7)]
				,['L', 45 * Math.cos(6 * 360/7), 45 * Math.sin(6 * 360/7)] 
				,['L', 45 * Math.cos(7 * 360/7), 45 * Math.sin(7 * 360/7)] */ 
//				,['Q', trPoints.p2.x, trPoints.p2.y, trPoints.p3.x, trPoints.p3.y]             // Точка: 4
			//    ,['Q', trPoints.p3.x1, trPoints.p3.y1, trPoints.p3.x, trPoints.p3.y]             // Точка: 4
//				,['A', -Radius_Mill, Radius_Mill, 0, 0, 0, trPoints.ps.x, trPoints.ps.y]
			//	,['z']
//			]);
			//alert(trajectoryPoint[2]);
//			alert(alphaC[90]);
			let trajectoryPath = canvasRT.path(trajectoryPoint).addClass('trajectoryPath_A')
                                       .fill({ color: SVG.Color.random()})
									   
                                       .stroke({ color: SVG.Color.random() });
    </script>
</html>